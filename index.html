<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Snake Game (Fixed Single HTML)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#111b2e;
      --text:#e8eefc;
      --muted:#9fb3d8;
      --accent:#4dd4ff;
      --danger:#ff5c7a;
      --grid:#1c2a46;
      --snake:#7CFF6B;
      --snakeHead:#2DFFB9;
      --food:#FFCC00;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(1200px 800px at 20% 10%, #16264a 0%, var(--bg) 55%, #070b14 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", sans-serif;
    }

    .wrap{ width:min(780px, 92vw); display:grid; gap:14px; }

    header{
      background:rgba(17,27,46,0.75);
      border:1px solid rgba(77,212,255,0.12);
      border-radius:14px;
      padding:14px 16px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      backdrop-filter: blur(8px);
    }
    .title{ display:flex; align-items:center; gap:10px; font-weight:800; }
    .badge{
      font-size:12px; padding:4px 10px; border-radius:999px;
      background:rgba(77,212,255,0.14);
      border:1px solid rgba(77,212,255,0.25);
      color:var(--accent); font-weight:700;
    }
    .stats{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
    .stat{
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.08);
      padding:8px 10px;
      border-radius:12px;
      display:flex;
      gap:8px;
      align-items:baseline;
      min-width:120px;
      justify-content:space-between;
    }
    .stat b{font-size:14px}
    .stat span{color:var(--muted); font-size:12px}

    .board{
      position:relative;
      background:rgba(17,27,46,0.65);
      border:1px solid rgba(77,212,255,0.12);
      border-radius:16px;
      padding:14px;
      backdrop-filter: blur(8px);
      overflow:hidden;
    }

    /* ìº”ë²„ìŠ¤ëŠ” CSSë¡œ í¬ê¸°ë§Œ ì§€ì •í•˜ê³ , ì‹¤ì œ ë Œë” í”½ì…€ì€ JSê°€ DPRì— ë§ê²Œ ì„¤ì • */
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:12px;
      background: rgba(9,14,26,0.2);
    }

    .overlay{
      position:absolute;
      inset:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }
    .card{
      width:min(520px, 92%);
      text-align:center;
      padding:18px 16px;
      border-radius:16px;
      background:rgba(9,14,26,0.78);
      border:1px solid rgba(255,255,255,0.10);
      box-shadow:0 18px 60px rgba(0,0,0,0.45);
    }
    .card h2{ margin:0 0 8px; font-size:20px; }
    .card p{ margin:0; color:var(--muted); font-size:14px; line-height:1.55; }
    .keys{
      margin-top:10px;
      display:flex; gap:8px; justify-content:center; flex-wrap:wrap;
      color:var(--text); opacity:0.95; font-size:12px;
    }
    kbd{
      font-family:inherit;
      font-size:12px;
      padding:4px 8px;
      border-radius:8px;
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
      box-shadow:0 2px 0 rgba(0,0,0,0.3);
    }
    .hint{ font-size:12px; color:var(--muted); padding:0 4px; text-align:center; }
    .danger{color:var(--danger)}
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">ğŸ Snake Game <span class="badge">Fixed</span></div>
      <div class="stats">
        <div class="stat"><span>ì ìˆ˜</span><b id="score">0</b></div>
        <div class="stat"><span>ìµœê³ ì </span><b id="best">0</b></div>
        <div class="stat"><span>ì†ë„</span><b id="speed">8</b></div>
      </div>
    </header>

    <div class="board">
      <canvas id="game" aria-label="Snake Game Canvas"></canvas>

      <div class="overlay" id="overlay">
        <div class="card">
          <h2 id="msgTitle">ì‹œì‘ ì•ˆë‚´</h2>
          <p id="msgBody">
            í™”ì‚´í‘œ í‚¤ë¡œ ì´ë™í•˜ì„¸ìš”. ë¨¹ì´ë¥¼ ë¨¹ìœ¼ë©´ ê¸¸ì–´ì§‘ë‹ˆë‹¤.<br/>
            ë²½/ìê¸° ëª¸ì— ë¶€ë”ªíˆë©´ <span class="danger">ê²Œì„ ì˜¤ë²„</span>!
          </p>
          <div class="keys">
            <kbd>â†‘</kbd><kbd>â†“</kbd><kbd>â†</kbd><kbd>â†’</kbd>
            <span style="width:10px;display:inline-block"></span>
            <kbd>Space</kbd><kbd>Enter</kbd><kbd>R</kbd>
          </div>
          <p class="hint">Space/Enter/R : ì‹œì‘/ì¬ì‹œì‘</p>
        </div>
      </div>
    </div>

    <div class="hint">ë°©í–¥ì„ ë°˜ëŒ€ë¡œ ë°”ë¡œ ë°”ê¾¸ëŠ” ê²ƒì€ ë°©ì§€ë˜ì–´ ìˆì–´ìš”.</div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const bestEl  = document.getElementById("best");
    const speedEl = document.getElementById("speed");

    const overlay = document.getElementById("overlay");
    const msgTitle = document.getElementById("msgTitle");
    const msgBody  = document.getElementById("msgBody");

    // ===== ì„¤ì • =====
    const gridCount = 24;   // 24x24
    const baseTPS = 8;      // ì´ˆë‹¹ ì´ë™
    const maxTPS  = 16;

    const BEST_KEY = "snake_best_score_v2";
    let bestScore = parseInt(localStorage.getItem(BEST_KEY) || "0", 10);
    bestEl.textContent = bestScore;

    // ë Œë”ë§ ì…€ í¬ê¸°(í”½ì…€)ëŠ” "í‘œì‹œë˜ëŠ” ìº”ë²„ìŠ¤ í­ / gridCount"ë¡œ ìë™ ê²°ì •
    let cell = 20;      // ì´ˆê¸°ê°’(ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ì¬ê³„ì‚°)
    let tps = baseTPS;

    // ìƒíƒœ
    let snake = [];
    let dir = {x:1, y:0};
    let nextDir = {x:1, y:0};
    let food = {x:10, y:10};
    let score = 0;
    let running = false;
    let gameOver = false;

    // ê²Œì„ ë£¨í”„(ê³ ì • tick)
    let tickTimer = null;

    function cssVar(name){
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function showOverlay(title, html){
      msgTitle.textContent = title;
      msgBody.innerHTML = html;
      overlay.style.display = "flex";
    }
    function hideOverlay(){ overlay.style.display = "none"; }

    function setCanvasSize(){
      // í™”ë©´ì— ë³´ì´ëŠ” ìº”ë²„ìŠ¤ì˜ CSS í”½ì…€ ë„ˆë¹„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ cell ê²°ì •
      const cssWidth = canvas.clientWidth || 600;
      cell = Math.floor(cssWidth / gridCount);
      if(cell < 10) cell = 10;

      // ìº”ë²„ìŠ¤ì˜ "í‘œì‹œ ë†’ì´"ë„ ì •ì‚¬ê°ìœ¼ë¡œ ë§ì¶”ê¸° ìœ„í•´ CSS ë†’ì´ë¥¼ ê°•ì œ
      canvas.style.height = (cell * gridCount) + "px";

      // DPR ë°˜ì˜í•˜ì—¬ ì‹¤ì œ ë Œë” í•´ìƒë„ ì¡°ì •
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.floor(cell * gridCount * dpr);
      canvas.height = Math.floor(cell * gridCount * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // ì´í›„ ì¢Œí‘œëŠ” CSS í”½ì…€ ê¸°ì¤€ìœ¼ë¡œ ê·¸ë¦¬ê¸°
      draw(); // ë¦¬ì‚¬ì´ì¦ˆ í›„ ë‹¤ì‹œ ê·¸ë¦¼
    }

    // ResizeObserverë¡œ ì•ˆì •ì ìœ¼ë¡œ ë¦¬ì‚¬ì´ì¦ˆ ê°ì§€
    const ro = new ResizeObserver(() => setCanvasSize());
    ro.observe(canvas);

    function resetGame(){
      score = 0;
      scoreEl.textContent = score;
      tps = baseTPS;
      speedEl.textContent = tps;

      const cx = Math.floor(gridCount/2);
      const cy = Math.floor(gridCount/2);
      snake = [
        {x:cx,   y:cy},
        {x:cx-1, y:cy},
        {x:cx-2, y:cy},
      ];
      dir = {x:1, y:0};
      nextDir = {x:1, y:0};
      food = spawnFood();

      running = false;
      gameOver = false;

      stopLoop();
      showOverlay(
        "ì‹œì‘ ì•ˆë‚´",
        "í™”ì‚´í‘œ í‚¤ë¡œ ì´ë™í•˜ì„¸ìš”. ë¨¹ì´ë¥¼ ë¨¹ìœ¼ë©´ ê¸¸ì–´ì§‘ë‹ˆë‹¤.<br/>ë²½/ìê¸° ëª¸ì— ë¶€ë”ªíˆë©´ <span class='danger'>ê²Œì„ ì˜¤ë²„</span>!"
      );
      draw();
    }

    function startGame(){
      if(gameOver) resetGame();
      if(running) return;
      running = true;
      hideOverlay();
      startLoop();
    }

    function endGame(){
      running = false;
      gameOver = true;
      stopLoop();

      if(score > bestScore){
        bestScore = score;
        localStorage.setItem(BEST_KEY, String(bestScore));
        bestEl.textContent = bestScore;
      }

      showOverlay(
        "ê²Œì„ ì˜¤ë²„!",
        `ì ìˆ˜: <b>${score}</b> / ìµœê³ ì : <b>${bestScore}</b><br/>Space/Enter/R ë¡œ ì¬ì‹œì‘í•˜ì„¸ìš”.`
      );
    }

    function startLoop(){
      stopLoop();
      tickTimer = setInterval(() => {
        step();
        draw();
      }, 1000 / tps);
    }
    function stopLoop(){
      if(tickTimer){
        clearInterval(tickTimer);
        tickTimer = null;
      }
    }
    function updateSpeed(){
      // ì ìˆ˜ 50ì ë§ˆë‹¤ 1 ì¦ê°€ (ìµœëŒ€ maxTPS)
      const newTPS = Math.min(maxTPS, baseTPS + Math.floor(score / 50));
      if(newTPS !== tps){
        tps = newTPS;
        speedEl.textContent = tps;
        if(running) startLoop(); // interval ì¬ì„¤ì •
      }
    }

    function randInt(min,max){
      return Math.floor(Math.random()*(max-min+1))+min;
    }
    function key(p){ return `${p.x},${p.y}`; }

    function spawnFood(){
      const occ = new Set(snake.map(key));
      let p;
      do{
        p = {x:randInt(0, gridCount-1), y:randInt(0, gridCount-1)};
      }while(occ.has(key(p)));
      return p;
    }

    function setDirection(nx, ny){
      // í˜„ì¬ ì§„í–‰ë°©í–¥ê³¼ ì™„ì „ ë°˜ëŒ€ë©´ ë¬´ì‹œ (ì¦‰ì‹œ ì—­ë°©í–¥ ë°©ì§€)
      if(nx === -dir.x && ny === -dir.y) return;
      nextDir = {x:nx, y:ny};

      // ë°©í–¥í‚¤ë¥¼ ëˆ„ë¥´ë©´ ì‹œì‘(ì²˜ìŒ/ëŒ€ê¸° ìƒíƒœì—ì„œ)
      if(!running && !gameOver) startGame();
    }

    window.addEventListener("keydown", (e) => {
      const k = e.key;
      if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(k)) e.preventDefault();

      switch(k){
        case "ArrowUp":    setDirection(0,-1); break;
        case "ArrowDown":  setDirection(0, 1); break;
        case "ArrowLeft":  setDirection(-1,0); break;
        case "ArrowRight": setDirection(1, 0); break;
        case " ":
        case "Enter":
        case "r":
        case "R":
          if(gameOver) resetGame();
          startGame();
          break;
      }
    }, {passive:false});

    function step(){
      if(!running) return;

      // ë°©í–¥ ì ìš©
      dir = nextDir;

      const head = snake[0];
      const newHead = {x: head.x + dir.x, y: head.y + dir.y};

      // ë²½ ì¶©ëŒ
      if(newHead.x < 0 || newHead.x >= gridCount || newHead.y < 0 || newHead.y >= gridCount){
        endGame(); return;
      }

      const willEat = (newHead.x === food.x && newHead.y === food.y);

      // ëª¸ ì¶©ëŒ: ë¨¹ì´ë¥¼ ì•ˆ ë¨¹ìœ¼ë©´ ê¼¬ë¦¬ê°€ ë¹ ì§ˆ ì˜ˆì •ì´ë¼ ë§ˆì§€ë§‰ ì¹¸ì€ ì œì™¸í•˜ê³  ê²€ì‚¬
      const body = willEat ? snake : snake.slice(0, -1);
      if(body.some(p => p.x === newHead.x && p.y === newHead.y)){
        endGame(); return;
      }

      snake.unshift(newHead);

      if(willEat){
        score += 10;
        scoreEl.textContent = score;
        food = spawnFood();
        updateSpeed();
      }else{
        snake.pop();
      }
    }

    function draw(){
      // ë°°ê²½
      ctx.clearRect(0,0, canvas.width, canvas.height);

      // ê²©ì ê·¸ë¦¬ê¸°
      ctx.save();
      ctx.strokeStyle = cssVar("--grid");
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 1;

      const w = cell * gridCount;
      const h = cell * gridCount;

      for(let i=0;i<=gridCount;i++){
        const x = i * cell;
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
        const y = i * cell;
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
      }
      ctx.restore();

      // ìŒì‹
      drawCell(food.x, food.y, cssVar("--food"));

      // ë±€
      snake.forEach((p,i)=>{
        drawCell(p.x, p.y, i===0 ? cssVar("--snakeHead") : cssVar("--snake"));
      });

      // ëˆˆ(ê°„ë‹¨)
      const h0 = snake[0];
      if(h0){
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        const cx = h0.x * cell;
        const cy = h0.y * cell;
        const eyeOffset = Math.max(4, Math.floor(cell*0.25));
        const ex1 = cx + cell/2 + (dir.x ? dir.x*eyeOffset : -eyeOffset/2);
        const ey1 = cy + cell/2 + (dir.y ? dir.y*eyeOffset : -eyeOffset/2);
        const ex2 = cx + cell/2 + (dir.x ? dir.x*eyeOffset : eyeOffset/2);
        const ey2 = cy + cell/2 + (dir.y ? dir.y*eyeOffset : eyeOffset/2);
        ctx.beginPath();
        ctx.arc(ex1, ey1, 2, 0, Math.PI*2);
        ctx.arc(ex2, ey2, 2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function drawCell(x,y,color){
      const pad = Math.max(2, Math.floor(cell*0.12));
      ctx.fillStyle = color;
      ctx.fillRect(x*cell + pad, y*cell + pad, cell - pad*2, cell - pad*2);
    }

    // ì´ˆê¸°í™”
    setCanvasSize();
    resetGame();
  </script>
</body>
</html>
